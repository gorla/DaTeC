package ch.unisi.inf.datec.instrument;import java.util.ArrayList;import java.util.Iterator;import java.util.Map;import soot.Body;import soot.BodyTransformer;import soot.Local;import soot.Scene;import soot.SootClass;import soot.SootMethod;import soot.Unit;import soot.ValueBox;import soot.jimple.FieldRef;import soot.jimple.InvokeExpr;import soot.jimple.Jimple;import soot.jimple.Stmt;import soot.jimple.StringConstant;import soot.util.Chain;import ch.unisi.inf.datec.DatecProperties;import ch.unisi.inf.datec.analyses.Utilities;import ch.unisi.inf.datec.db.DBinterface;public class DefInstrumenter extends BodyTransformer {//	private SootClass coverageCalculator;//	private SootMethod checkDef;	static SootClass coverageCalculator;	static SootMethod checkDef;	static {		coverageCalculator = Scene.v().loadClassAndSupport(				"ch.unisi.inf.datec.instrument.CoverageCalculator");		checkDef = coverageCalculator.getMethod("void checkDef(java.lang.String,int)");	}		protected void internalTransform(Body body, String phase, Map options) {		if(body.getMethod().getDeclaringClass().getName().contains("$"))			return;		//		coverageCalculator = Scene.v().loadClassAndSupport("ch.unisi.inf.datec.instrument.CoverageCalculator");//		checkDef = coverageCalculator.getMethod("void checkDef(java.lang.String,int)");				SootMethod method = body.getMethod();		if(!DBinterface.shouldBeInstrumented(method.getSignature())){			if(DatecProperties.getInstance().isVerbose())				System.out.println("skipping defs of method : " + method.getSignature());			return;		}				// debugging		if(DatecProperties.getInstance().isVerbose())			System.out.println("instrumenting defs of method : " + method.getSignature());		Chain units = body.getUnits();		Iterator<Unit> stmtIt = units.snapshotIterator();				Local hc = body.getLocals().getLast();		// typical while loop for iterating over each statement		while (stmtIt.hasNext()) {			// cast back to a statement.			Stmt stmt = (Stmt) stmtIt.next();						//If the statement contains a field ref...			if (stmt.containsFieldRef()) {				ArrayList<ValueBox> defIt = new ArrayList<ValueBox>(stmt						.getDefBoxes());				for (ValueBox v : defIt) {					// ignore non field defs					if (!(v.getValue() instanceof FieldRef))						continue;//					int id = v.getValue().hashCode();					String id = "D-"+((FieldRef) v.getValue()).getField().getSignature()+"-"+method.getSignature()+"-"+Utilities.getLineNumber(stmt);										if(!DBinterface.shouldBeInstrumented(id, 1)){						if(DatecProperties.getInstance().isVerbose())							System.out.println("skipping definition: "+id);						continue;					}					InvokeExpr checkDExpr = Jimple.v().newStaticInvokeExpr(							checkDef.makeRef(), StringConstant.v(id), hc);					Stmt checkDStmt = Jimple.v().newInvokeStmt(checkDExpr);					units.insertBefore(checkDStmt, stmt);				}			}		}	}}